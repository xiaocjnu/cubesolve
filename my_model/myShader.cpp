// myShader.cpp// 这是一个自动生成的文件,请不要编辑!!!


#include"myShader.h"


namespace my
{
	const char* vertexShader_es11 =
		"#version 300 es\n"
		"//**************************************************************\n"
		"//\n"
		"// OpenGL ES 3.0 vertex shader that implements the following\n"
		"// OpenGL ES 1.1 fixed-function pipeline\n"
		"//\n"
		"// - compute lighting equation for up to eight directional/point/spotlights\n"
		"// - transform position to clip coordinates\n"
		"// - texture coordinate transforms for up to two texture coordinates\n"
		"// - compute fog factor\n"
		"// - compute user clip plane dot product (stored as v_ucp_factor)\n"
		"//\n"
		"//**************************************************************\n"
		"#define NUM_TEXTURES 2\n"
		"#define NUM_LIGHTS 8\n"
		"#define GLI_FOG_MODE_LINEAR 0\n"
		"#define GLI_FOG_MODE_EXP 1\n"
		"#define GLI_FOG_MODE_EXP2 2\n"
		"\n"
		"\n"
		"struct light\n"
		"{\n"
		"	vec4 position; 	// light position (in eye space) for a point/spotlight or normalized dir. for a directional light\n"
		"	vec4 ambient_color;\n"
		"	vec4 diffuse_color;\n"
		"	vec4 specular_color;\n"
		"	vec3 spot_direction;\n"
		"	vec3 attenuation_factors;\n"
		"	float spot_exponent;\n"
		"	float spot_cutoff_angle;\n"
		"	bool compute_distance_attenuation;\n"
		"};\n"
		"\n"
		"struct material\n"
		"{\n"
		"	vec4 ambient_color;\n"
		"	vec4 diffuse_color;\n"
		"	vec4 specular_color;\n"
		"	vec4 emissive_color;\n"
		"	float specular_exponent;\n"
		"};\n"
		"\n"
		"const float c_zero = 0.0;\n"
		"const float c_one = 1.0;\n"
		"const int indx_zero = 0;\n"
		"const int indx_one = 1;\n"
		"\n"
		"\n"
		"uniform mat4 mvp_matrix; // combined model-view + projection matrix\n"
		"uniform mat4 modelview_matrix; // model-view matrix\n"
		"uniform mat3 inv_transpose_modelview_matrix; // inverse model-view matrix used to transform normal\n"
		"uniform mat4 tex_matrix[NUM_TEXTURES]; // texture matrices\n"
		"uniform bool enable_tex[NUM_TEXTURES]; // texture enables\n"
		"uniform bool enable_tex_matrix[NUM_TEXTURES]; // texture matrix enables\n"
		"uniform material material_state;\n"
		"uniform vec4 ambient_scene_color;\n"
		"uniform light light_state[NUM_LIGHTS];\n"
		"uniform bool light_enable_state[NUM_LIGHTS]; // booleans to indicate which of eight lights are enabled\n"
		"uniform int num_lights; // number of lights enabled = sum of light_enable_state bools set to TRUE\n"
		"uniform bool enable_lighting; // is lighting enabled\n"
		"uniform bool light_model_two_sided; // is two-sided lighting enabled\n"
		"uniform bool enable_color_material; // is color material enabled\n"
		"uniform bool enable_fog; // is fog enabled\n"
		"uniform float fog_density;\n"
		"uniform float fog_start, fog_end;\n"
		"uniform int fog_mode; // fog mode: linear, exp, or exp2\n"
		"uniform bool xform_eye_p; // xform_eye_p is set if we need Peye for user clip plane, lighting, or fog\n"
		"uniform bool rescale_normal; // is rescale normal enabled\n"
		"uniform bool normalize_normal; // is normalize normal enabled\n"
		"uniform float rescale_normal_factor; // rescale normal factor if glEnable(GL_RESCALE_NORMAL)\n"
		"uniform vec4 ucp_eqn; // user clip plane equation; one user clip plane specified\n"
		"uniform bool enable_ucp; // is user clip plane enabled\n"
		"\n"
		"\n"
		"//******************************************************\n"
		"// vertex attributes: not all of them may be passed in\n"
		"//******************************************************\n"
		"in vec4 a_position; // this attribute is always specified\n"
		"in vec4 a_texcoord0; // available if enable_tex[0] is true\n"
		"in vec4 a_texcoordl; // available if enable_tex[1] is true\n"
		"in vec4 a_color; // available if !enable_lighting or (enable_lighting && enable_color_material)\n"
		"in vec3 a_normal; // available if xform_normal is set (required for lighting)\n"
		"\n"
		"//************************************************\n"
		"// output variables of the vertex shader\n"
		"//************************************************\n"
		"out vec4 v_texcoord0;\n"
		"out vec4 v_texcoord1;\n"
		"out vec4 v_front_color;\n"
		"out vec4 v_back_color;\n"
		"out float v_fog_factor;\n"
		"out float v_ucp_factor;\n"
		"\n"
		"//************************************************\n"
		"// temporary variables used by the vertex shader\n"
		"//************************************************\n"
		"vec4 p_eye;\n"
		"vec3 n;\n"
		"vec4 mat_ambient_color;\n"
		"vec4 mat_diffuse_color;\n"
		"\n"
		"\n"
		"\n"
		"vec4 lighting_equation ( int i )\n"
		"{\n"
		"	vec4 computed_color = vec4( c_zero, c_zero, c_zero, c_zero );\n"
		"	vec3 h_vec;\n"
		"	float ndotl, ndoth;\n"
		"	float att_factor;\n"
		"	vec3 VPpli;\n"
		"	\n"
		"	\n"
		"	att_factor = c_one;\n"
		"	\n"
		"	if ( light_state[i].position.w != c_zero )\n"
		"	{\n"
		"		float spot_factor;\n"
		"		vec3 att_dist;\n"
		"		// this is a point or spotlight we assume \"w\" values for PPli and V are the same\n"
		"		VPpli = light_state[i].position.xyz - p_eye.xyz;\n"
		"		\n"
		"		//if ( xform_eye_p )\n"
		"		//{\n"
		"		//	vec4 VPpli4 = modelview_matrix * light_state[i].position;\n"
		"		//	VPpli = VPpli4.xyz - p_eye.xyz;\n"
		"		//}\n"
		"		\n"
		"		\n"
		"		if ( light_state[i].compute_distance_attenuation )\n"
		"		{\n"
		"			// compute distance attenuation\n"
		"			att_dist.x = c_one;\n"
		"			att_dist.z = dot ( VPpli, VPpli );\n"
		"			att_dist.y = sqrt ( att_dist.z ) ;\n"
		"			att_factor = c_one / dot ( att_dist,\n"
		"			light_state[i] .attenuation_factors );\n"
		"		}\n"
		"		\n"
		"		VPpli = normalize ( VPpli );\n"
		"		if ( light_state[i].spot_cutoff_angle < 180.0 )\n"
		"		{\n"
		"			// compute spot factor\n"
		"			spot_factor = dot ( -VPpli,\n"
		"			light_state[i].spot_direction );\n"
		"			\n"
		"			if( spot_factor >= cos(radians(light_state[i].spot_cutoff_angle)))\n"
		"				spot_factor = pow(spot_factor, light_state[i].spot_exponent);\n"
		"			else\n"
		"				spot_factor = c_zero;\n"
		"		\n"
		"			att_factor *= spot_factor;\n"
		"		}\n"
		"	}\n"
		"	else\n"
		"	{\n"
		"		// directional light\n"
		"		VPpli = light_state[i].position.xyz;\n"
		"		\n"
		"		//if ( xform_eye_p )\n"
		"		//{\n"
		"		//	vec4 VPpli4 = modelview_matrix * light_state[i].position;\n"
		"		//	VPpli = normalize(VPpli4.xyz);\n"
		"		//}\n"
		"			\n"
		"	}\n"
		"	\n"
		"	if( att_factor > c_zero )\n"
		"	{\n"
		"		// process lighting equation --> compute the light color\n"
		"		computed_color += ( light_state[i].ambient_color *\n"
		"		mat_ambient_color );\n"
		"		ndotl = max( c_zero, dot( n, VPpli ) );\n"
		"		\n"
		"		computed_color += ( ndotl * light_state[i].diffuse_color * mat_diffuse_color );\n"
		"		\n"
		"		h_vec = normalize( VPpli + vec3(c_zero, c_zero, c_one ) );\n"
		"		ndoth = dot ( n, h_vec );\n"
		"		\n"
		"		if ( ndoth > c_zero )\n"
		"		{\n"
		"			computed_color += ( pow ( ndoth,\n"
		"			material_state.specular_exponent ) *\n"
		"			material_state.specular_color *\n"
		"			light_state[i].specular_color );\n"
		"		}\n"
		"		\n"
		"\n"
		"		computed_color *= att_factor; // multiply color with computed attenuation factor * computed spot factor\n"
		"		\n"
		"\n"
		"	}\n"
		"	return computed_color;\n"
		"}\n"
		"\n"
		"\n"
		"float compute_fog( )\n"
		"{\n"
		"	float f;\n"
		"	// use eye Z as approximation\n"
		"	if ( fog_mode == GLI_FOG_MODE_LINEAR )\n"
		"	{\n"
		"		f = ( fog_end - p_eye.z ) / ( fog_end - fog_start );\n"
		"	}\n"
		"	else if ( fog_mode == GLI_FOG_MODE_EXP )\n"
		"	{\n"
		"		f = exp( - ( p_eye.z * fog_density ) );\n"
		"	}\n"
		"	else\n"
		"	{\n"
		"		f = ( p_eye.z * fog_density );\n"
		"		f = exp( -( f * f ) );\n"
		"	}\n"
		"	\n"
		"	f = clamp ( f, c_zero, c_one) ;\n"
		"	return f;\n"
		"}\n"
		"\n"
		"\n"
		"vec4 do_lighting()\n"
		"{\n"
		"	vec4 vtx_color;\n"
		"	int i, j ;\n"
		"	vtx_color = material_state.emissive_color + ( mat_ambient_color * ambient_scene_color );\n"
		"	j = int( c_zero );\n"
		"	\n"
		"	for ( i=int( c_zero ); i<NUM_LIGHTS; i++ )\n"
		"	{\n"
		"		if ( j >= num_lights )\n"
		"			break;\n"
		"			\n"
		"		if (true)// light_enable_state[i] )\n"
		"		{\n"
		"			j++;\n"
		"			vtx_color += lighting_equation(i);\n"
		"		}\n"
		"	}\n"
		"	\n"
		"	vtx_color.a = mat_diffuse_color.a;\n"
		"	return vtx_color;\n"
		"}\n"
		"\n"
		"void main( void )\n"
		"{\n"
		"	int i, j;\n"
		"	// do we need to transform P\n"
		"	if ( xform_eye_p )\n"
		"		p_eye = modelview_matrix * a_position;\n"
		"	\n"
		"	\n"
		"	if ( enable_lighting )\n"
		"	{\n"
		"		n = inv_transpose_modelview_matrix * a_normal;\n"
		"		\n"
		"		if ( rescale_normal )\n"
		"			n = rescale_normal_factor * n;\n"
		"	\n"
		"		if ( normalize_normal )\n"
		"			n = normalize(n);\n"
		"		\n"
		"		\n"
		"		mat_ambient_color = enable_color_material ? a_color : material_state.ambient_color;\n"
		"		mat_diffuse_color = enable_color_material ? a_color : material_state.diffuse_color;\n"
		"		\n"
		"\n"
		"		v_front_color = do_lighting();\n"
		"		v_back_color = v_front_color;\n"
		"		\n"
		"		// do two-sided lighting\n"
		"		if ( light_model_two_sided )\n"
		"		{\n"
		"			n = -n;\n"
		"			v_back_color = do_lighting( );\n"
		"		}\n"
		"		\n"
		"	}\n"
		"	else\n"
		"	{\n"
		"		// set the default output color to be the per-vertex / per-primitive color\n"
		"		v_front_color = a_color;\n"
		"		v_back_color = a_color;\n"
		"	}\n"
		"	\n"
		"	// do texture transforms\n"
		"	v_texcoord0 = vec4(c_zero, c_zero, c_zero, c_one);\n"
		"	\n"
		"	if ( enable_tex[0] )\n"
		"	{\n"
		"		if ( enable_tex_matrix[indx_zero] )\n"
		"			v_texcoord0 = tex_matrix[indx_zero] * a_texcoord0;\n"
		"		else\n"
		"			v_texcoord0 = a_texcoord0;\n"
		"	}\n"
		"	\n"
		"	\n"
		"	v_texcoord1 = vec4(c_zero, c_zero, c_zero, c_one);\n"
		"	\n"
		"	if ( enable_tex[indx_one] )\n"
		"	{\n"
		"		if ( enable_tex_matrix[indx_one] )\n"
		"			v_texcoord1 = tex_matrix[indx_one] * a_texcoordl;\n"
		"		else\n"
		"			v_texcoord1 = a_texcoordl;\n"
		"	}\n"
		"	\n"
		"	v_ucp_factor = enable_ucp ? dot ( p_eye, ucp_eqn ) : c_zero;\n"
		"	v_fog_factor = enable_fog ? compute_fog( ) : c_one;\n"
		"	\n"
		"	gl_Position = mvp_matrix * a_position;\n"
		"}\n";


	const char* fragmentShader_es11 =
		"#version 300 es\n"
		"\n"
		"precision mediump float;\n"
		"\n"
		"uniform sampler2D sampler;\n"
		"uniform bool enable_tex[2]; // texture enables\n"
		"\n"
		"\n"
		"\n"
		"in vec4 v_texcoord0;\n"
		"in vec4 v_texcoord1;\n"
		"in vec4 v_front_color;\n"
		"in vec4 v_back_color;\n"
		"in float v_fog_factor;\n"
		"in float v_ucp_factor;\n"
		"\n"
		"out vec4 fragmentColor;\n"
		"\n"
		"void main()\n"
		"{\n"
		"	if (enable_tex[0])\n"
		"	{\n"
		"		vec4 texColor = texture(sampler, v_texcoord0.xy);\n"
		"		fragmentColor = v_front_color * texColor;\n"
		"	}\n"
		"	else\n"
		"	{\n"
		"		fragmentColor = v_front_color;\n"
		"	}\n"
		"	\n"
		"\n"
		"	//fragmentColor = v_front_color;\n"
		"	//fragmentColor.a = 1.0;\n"
		"	//fragmentColor = vec4(0.5,0.5,0.5,1.0);\n"
		"}";


}
